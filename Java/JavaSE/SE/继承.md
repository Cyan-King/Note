## 设计模式
建筑行业，每次盖房子都会涉及到一些问题？
所以要把有效的设计方式给记下来
这个三个步骤就做到了对象的唯一性


# 继承
* 继承的好处：
 * 1.提高了代码的复用性
 * 2.让类与类之间产生了关系，给第三个特征多态提供了前提
    *
 * java中支持单继承。不直接支持多继承，但对C++中的多继承机制进行改良
    *
 * 单继承：一个子类只能有一个直接父类
    *
 * 多继承：一个子类可以有多个直接父类（java中不允许，进行改良）
 * 不直接支持，因为多个父类中有相同成员，会产生调用不确定性。
    *
 * java支持多层（多重）继承
    *
 * C继承B， B继承A
  当要使用一个继承体系时
 * 1.查看该体系中的顶层类，了解该体系的基本功能
 * 2.创建体系中的最子类对象，完成功能的使用
    *
 * 什么时候定义继承呢？
    *
 * 当类与类之间存在这所属关系的时候，就定义继承。
    *
 * 所属关系： is a 关系。
* 在子父类中，成员的特点体现
 * 1.成员变量
 * 2.成员函数
 * 3.构造函数
    *
 * 当本类的成员和局部变量同名用this区分
 * 当子父类中的成员变量同名用super区分父类
    *
 * this和super很相识
    *
 * this代表一个本类对象的引用
 * super：代表一个父类空间
* 成员函数
   *
 * 当子父类中的出现成员函数一摸一样的情况，会运行子类的函数
 * 这种现象，称为覆盖操作吗。这时函数在子父类中的特性
 * 函数的两个特性
 * 1.重载。同一个类中。overload
 * 2.覆盖。子类中。覆盖也称为重写，覆写，override
    *
 * 覆盖注意事项
 * 1.子类方法覆盖父类方法时，子类权限必须大于等于父类的权限
* 2.静态这个能覆盖静态，或被静态覆盖
   *
 * 什么时候使用覆盖操作
    *
 * 当对一个类进行子类的扩展时，子类需要保留父类的功能声明
 * 但是要定义子类中该功能的特有内容时，就使用覆盖操作完成
  子父类中的构造函数的特点
   *
 * 在子类构造对象，发现，访问子类构造函数，父类也运行。
 * 为什么呢？
 * 原因是：在子类的构造函数中第一行有一个默认的隐式语句。super();
    *
 * 子类的实例化工程：子类中所有的构造函数默认都会访问父类中的空参数的构造函数
    *
 * 为什么子类实例化的时候要访问父类中的构造函数呢？
 * 那是因为子类·继承了父类，获取到了父类中内容（属性），所以在使用父类内容之前
 * 要先看父类是如何对自己的内容进行出事化的。
    *
 * 所以子类在构造对象时，必须访问父类中的构造函数
 * 为什么完成这个必须的动作，就在子类的构造函数中加入了super().语句
    *
 * 如果父类中没有定义空参数后汉书，那么子类的够着函数必须用super明确要调用
 * 父类中哪个构造函数。同时子类构造函数如果使用this调用了本类构造函数时，
 * 那么super就没有了，因为super和this都只能定义第一行，所以只能有一个。
 * 但是可以保证的时，子类中肯定会有其他的构造函数访问父类的构造函数。
    *
 * 注意：super语句必须要定义在子类构造函数的第一行，因为父类的初始化动作要先完成
  一个对象实例化过程
 * Person p = new Person();
 * 1.JVM会读取指定的路径下的Person.class文件，并加载进内存
 * 并会先加载Person的父类（如果有直接的父类的情况下）。
 * 2.在堆内存中的开辟空间，分配地址
 * 3.并在对象空间中，对对象中的属性进行默认初始化。
 * 4.调用对应的构造函数进行初始化
 * 5.在构造函数中，第一行会先调用父类中的构造函数进行初始化。
 * 6.父类初始化完毕后，在对子类的属性进行显示初始化
 * 4.在进行子类构造函数的特定初始化
 * 8.初花完毕后，将地址值赋值给引用变量
  final关键字
  常量值用大写
* 1.final是一个修饰符，可以修饰类，方法，变量。
 * 2.final修饰的类不可以被继承。
 * 3.final修饰的方法不可以被覆盖。
 * 4.final修饰的变量时一个常量，只能赋值一次。
 * 为什么要用final修饰变量。其实在程序如果一个数据是固定的
 * 那么直接使用这个数据就可以了，但是这样阅读性差所以它该数据起了个名称
 * 而且这个变量名称的值不能变化，所以加上final固定
    *
 * 写法规范：常量所有字母都有大写，多个单纯，中间用_连接
  抽象类
* 抽象额类：
 * 抽象：笼统，模糊，看不清！不具体
 * abstract   抽象的关键字
    *
 * 特点：
 * 1.方法只有声明没有实现，该方法就是抽象方法，需要被abstract修饰
 * 抽象方法必须定义在抽象类中。该类必须也被abstract修饰
 * 2.抽象方法不可以被实例化。为什么？因为调用抽象方法没有意义
 * 3.抽象类必须有其子类覆盖了所有的抽象方法后，该子类才可以实例化。
 * 否则，这个子类还是抽象类。
    *
     *
 * 1.抽象类中有构造函数吗？
 * 有，用于给子类对象进行初始化？
    *
 * 2.抽象类可以不定义抽象方法吗？
 * 可以的，但是很少见，目的就是不让该类创建对象。AWT的适配器对象就是这种类。
 * 通常这个类中的方法有方法体，但是却没有内容
    *
 * abstract class Demo
 * {
 * void show1()
 * {}
    *
 * void show2()
 * {}
 * }
    *
 * 3.抽象关键字不可以和那些关键字共存？
 * private 不行----非法修饰符组合：abstract 和 private
 * static  不行----非法修饰符组合：abstract 和 static
 * final 不行----final修饰的方法不能覆盖
 * 
    *
 * 4.抽象类和一般类的异同点。
 * 相同点：抽象类和一般类都是用来描述事物的，都在内部定了成员。
 * 不同：1.一般类有足够的信息描述事物。
 * 抽象了哦描述事物的信息有可能不足。
 * 2.一般类中可定义抽象方法，同时也可以定义非抽象方法。
 * 抽象类中可定义抽象方法，同时也可以定义非抽象方法。
 * 3.一般类可以被实力化。
 * 抽象类不可以被实例化。
    *
 * 5.抽象类一定是一个父类吗？
 * 是的。因为需要子类覆盖其方法后才可以对子类实例化
  接口
* 当一个抽象类中的方法都是抽象的时候，这时可以将该抽象类用
 * 另一种形式定义和表示，就是 接口  interface
    *
 * 定义接口使用的关键字不是class， 时infterface
 * 对于接口当中常见的成员：而且这些成员都有固定的修饰符
 * 1.全局常量：public static final
    *
 * 2.抽象方法:public abstract
    *
 * 由此得出结论，接口中的成员都时公共的权限
    *
 * 类与类之间是继承关系，类与接口直接是实现关系。
    *
 * 接口不可以实例化
    *
 * 只能由实现了接口的子类并覆盖了接口中所有的抽象方法后，该子类才可以实例化
 * 否则，这个子类就是一个抽象类
    *
 * 在java中不直接支持多继承，因为会出现调用的不确定性。
 * 所以java将多继承机制进行改良，在java中变成了多实现
    *
 * 一个类可以实现对各接口
* 抽象类和接口的异同点
   *
 * 相同点：
 * 都是不断向上抽取而来的
    *
 * 不同点
 * 1.抽象类需要被继承，而且只能单继承。
 * 接口需要被实现，而且可以多实现。
 * 2.抽象类中可以定义抽象方法和非抽象方法，子类继承后，可以直接使用非抽象方法。
 * 接口中只能定义抽象方法，必须由子类去实现。
 * 3.抽象类的继承，是is a 关系，在定义该体系的基本共性内容。
 * 接口的实现是like a关系，在定义体系额外功能。
 * 
    *
 * 犬按功能分：导盲犬，搜爆犬
    *
 * interface 犬
 * {
 * //不确定怎样吼叫所以用抽象方法
 * abstract void 吼叫();
 * }
    *
 * interface 导盲
 * {
 * abstract void 吼叫();
 * }
    *
 * class 导盲犬 extends 犬
 * {
 * public void 吼叫()
 * {
 * }
 * public void 导盲()
 * {
 * }
 * }
